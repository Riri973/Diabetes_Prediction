# -*- coding: utf-8 -*-
"""SBL: Diabetes Prediction

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B0uBC5EGfwKKdzwKjVeC3cD2kr6ocAof

Problem Statement:
Diabetes is one of the major cause of concern in the developing countries of the world, especially India. Many cases of Diabetes go undiagnosed, which later leads to a lot of complications of the individual. The Detection and Diagnosis for this particular disease is really important as they together can help bring the disease in control for the masses. Prediction plays a really important role in the diagnosis of the particular disease as a nearly accurate model cabn help in deciding whether a person shall go for the testing or not. Nowadays with teh advancement in technology andthe various economic and commercial revolutions i India, majority of Indians have a smartphone. The following code can be useful for those individuals to test whether they have diabetes or not, by deploying the app through certain goernment agencies.
"""

import pandas

# We are importing PANDAS; Pandas is used for working with datasets in python (exploring and manipulation)

import numpy           # Used to work with arrays, matrices, etc to perform high-level math operations 
import matplotlib      # Used to visualize the dataset that has been analysed
import seaborn         # Used to visualise random distribution dataset

pip install scikit-learn     # Machine Learning Library for classification, regression and clustering algorithms

# Commented out IPython magic to ensure Python compatibility.
#importing Libraries
import numpy as np   
np.random.seed(42)   # Initiates the random number generator with 42
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
# import scikit-plot
# %matplotlib inline  

#models
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC

#Evaluation
from sklearn.model_selection import train_test_split,cross_val_score
from sklearn.model_selection import RandomizedSearchCV,GridSearchCV
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.metrics import precision_score, recall_score, f1_score
# from sklearn.metrics import plot_roc_curve
#from scikitplot.metrics import plot_roc_curve
from sklearn.metrics import roc_curve

#for deprecation warning
from warnings import filterwarnings
filterwarnings("ignore")

# Read the CSV file
data = pd.read_csv("https://raw.githubusercontent.com/Abhayparashar31/Diabetes-prediction/master/diabetes.csv")

# Scraping the CSV file in order to print the contents

print(data.shape)  # Return the shape of data 
print(data.ndim)   # Return the n dimensions of data
print(data.size)   # Return the size of data 
print(data.isna().sum())  # Returns the sum fo all na values
print(data.info())  # Give concise summary of a DataFrame

#To get the bar graphs of people who have diabetes as per our table
data["Outcome"].value_counts().plot(kind="bar",color=["salmon","deeppink"])
plt.xticks(np.arange(2), ('No Diabetes', 'Diabetes'),rotation=0);     # It specifies the requirements for the ticks in the graph using matplotline and NumPy- range)

# Comparing Glucose with the Outcome

pd.crosstab(data.Glucose[::15],data.Outcome).plot(kind="bar",figsize=(18,8),color=["yellow","deeppink"])  # Used to compute the factors across the table
plt.ylabel("people");
plt.xticks(rotation=0);  # No change in the rotation of the ticks on the X-axis
plt.legend(['No Diabetes', 'Diabetes']);

# Find out Blood Pressure and age of entries who have diabetes
plt.figure(figsize=(10,6))

# Scatter with positive example
plt.scatter(data.Age[data.Outcome==1],data.BloodPressure[data.Outcome==1],c="Red");

# Scatter with negative example
plt.scatter(data.Age[data.Outcome==0],data.BloodPressure[data.Outcome==0],c="lightblue");

# Add some helpful info
plt.title("Diabetes in function of Age and Blood pressure")
plt.xlabel("Age")
plt.ylabel("Blood Pressure")
plt.legend(["Diabetes","No Diabetes"]);

# Pairplotting of dataframe
import seaborn as sns
sns.set(style="ticks", color_codes=True)
sns.pairplot(data,hue='Outcome',palette='gnuplot');

# Histogram of all coloumns when the Outcome is 1( has Diabetes)
# Code block specifies all the parameters that will be required for the graph-plotting

fig, ax = plt.subplots(nrows=4, ncols=2, figsize=(12, 10))
fig.tight_layout(pad=3.0)
ax[0,0].set_title('Glucose')
ax[0,0].hist(data.Glucose[data.Outcome==1]);
ax[0,1].set_title('Pregnancies')
ax[0,1].hist(data.Pregnancies[data.Outcome==1]);
ax[1,0].set_title('Age')
ax[1,0].hist(data.Age[data.Outcome==1]);
ax[1,1].set_title('Blood Pressure')
ax[1,1].hist(data.BloodPressure[data.Outcome==1]);
ax[2,0].set_title('Skin Thickness')
ax[2,0].hist(data.SkinThickness[data.Outcome==1]);
ax[2,1].set_title('Insulin')
ax[2,1].hist(data.Insulin[data.Outcome==1]);
ax[3,0].set_title('BMI')
ax[3,0].hist(data.BMI[data.Outcome==1]);
ax[3,1].set_title('Diabetes Pedigree Function')
ax[3,1].hist(data.DiabetesPedigreeFunction[data.Outcome==1]);

# correlation matrix between columns
## It shows the correlation(positive,neagative) between different columns(only integer value columns) 
corr_matrix = data.corr()
fig, ax= plt.subplots(figsize=(15,10))
fig, ax = sns.heatmap(corr_matrix,annot=True,linewidth=0.5,fmt=".2f",cmap="YlGnBu")

#random data shuffeling; in order to train the model
data.sample(frac=1)

#Spliting the data
X = data.drop("Outcome",axis=1)
y = data["Outcome"]
X_train,X_test,y_train,y_test =  train_test_split(X,y,test_size=0.2)

## Build an model (Logistic Regression)
from sklearn.linear_model import LogisticRegression
log_reg = LogisticRegression(random_state=0)
log_reg.fit(X_train,y_train);

## Evaluating the model
log_reg = log_reg.score(X_test,y_test)

## Build an model (KNN- K Nearest Neighbour Algorithm)
knn = KNeighborsClassifier()
knn.fit(X_train,y_train);

## Evaluating the model
knn = knn.score(X_test,y_test)

## Build an model (Random forest classifier- consists of a large number of tress that contain datasets to operate in unison)
clf= RandomForestClassifier()
clf.fit(X_train,y_train);

## Evaluating the model
clf = clf.score(X_test,y_test)

## Build an model (Support Vector Machine- Used for classification of regression)
svm = SVC()
svm.fit(X_train,y_train)

## Evaluating the model
svm = svm.score(X_test,y_test)

model_compare = pd.DataFrame({"Logistic Regression":log_reg,
"KNN":knn,
"Random Forest Classifier":clf,
"Support Vector Machine":svm,},
index=["accuracy"])
model_compare.T.plot.bar(figsize=(15,10));
##############OUTPUT###############

# Create a hyperparameter grid for LogisticRegression
log_reg_grid = {"C": np.logspace(-4, 4, 20),"solver": ["liblinear"]}
# Tune LogisticRegression
np.random.seed(42)
# Setup random hyperparameter search for LogisticRegression
rs_log_reg = RandomizedSearchCV(LogisticRegression(),
                                  param_distributions=log_reg_grid,
                                  cv=5,
                                  n_iter=20,
                                  verbose=True)
# Fit random hyperparameter search model for LogisticRegression
rs_log_reg.fit(X_train, y_train)
score = rs_log_reg.score(X_test,y_test)
print(score*100)
##########OUTPUT###########
#83.11688311688312

log_reg_grid = {'C': np.logspace(-4,4,30),
"solver":["liblinear"]}
#setup  the gird cv
gs_log_reg = GridSearchCV(LogisticRegression(),
                          param_grid=log_reg_grid,
                          cv=5,
                           verbose=True)
#fit grid search cv
gs_log_reg.fit(X_train,y_train)
score = gs_log_reg.score(X_test,y_test)
print(score*100)

########OUTPUT#########
#83.76623376623377

# Entered candidates have diabetes or not- 1 is YES, 0 is NO)

y_preds = gs_log_reg.predict(X_test)
y_preds

sns.set(font_scale=2)
import seaborn as sns
sns.heatmap(confusion_matrix(y_test,y_preds), annot=True,cbar=False, fmt='g')
plt.xlabel("True label")
plt.ylabel("Predicted label");

# Print the results of the model
print(classification_report(y_test, y_preds))

# Plot giving two threshold points- the NEGATIVE threshold and the POSITIVE threshold
roc_curve(gs_log_reg, X_test,y_test)

# Save trained model to file
import pickle
pickle.dump(gs_log_reg, open("Diabetes.pkl", "wb"))
loaded_model = pickle.load(open("Diabetes.pkl", "rb"))
loaded_model.predict(X_test)
loaded_model.score(X_test,y_test)

import flask

from flask import Flask,request, url_for, redirect, render_template  ## importing necessary libraries
import pickle  ## pickle for loading model(Diabetes.pkl)
import pandas as pd  ## to convert the input data into a dataframe for giving as a input to the model

app = Flask("DP")  ## setting up flask name

model = pickle.load(open("Diabetes.pkl", "rb"))  ##loading model


@app.route('/')             ## Defining main index route
def home():
    return render_template("index.html")   ## showing index.html as homepage


@app.route('/predict',methods=['POST','GET'])  ## this route will be called when predict button is called
def predict(): 
    #int_features=[float(x) for x in request.form.values()]
    Pregnant = request.form['1']      ## Fetching each input field value one by one
    Glucose = request.form['2'] 
    BP = request.form['3']
    Insulin = request.form['4']
    ST = request.form['5']
    BMI = request.form['6']
    Age = request.form['7']
    DPF = request.form['8']
 
    row_df = pd.DataFrame([pd.Series([Pregnant, Glucose, BP, Insulin, ST, BMI, Age, DPF])])  ### Creating a dataframe using all the values
    print(row_df)
    prediction=model.predict_proba(row_df) ## Predicting the output
    output='{0:.{1}f}'.format(prediction[0][1], 2)    ## Formating output

    if output>str(0.5):
        return render_template('index.html',pred='You have chance of having diabetes.\nProbability of having Diabetes is {}'.format(output)) ## Returning the message for use on the same index.html page
    else:
        return render_template('index.html',pred='You are safe.\n Probability of having diabetes is {}'.format(output)) 




if 'DP' == '__main__':
    app.run(debug=True)          ## Running the app as debug==True